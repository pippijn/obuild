open build/C
open build/OCaml

# Global configuration
INSTALL_INTERFACES	= true
OCAMLFLAGS		= -annot -principal
OCAMLOPTFLAGS		= -g

# Empty defaults
global.CHeaders[]	= $(EMPTY)
global.CSources[]	= $(EMPTY)
global.Requires[]	= $(EMPTY)
global.Flags		= $(Map)

#
# This project requires ocamlfind (default - false).
#
global.USE_OCAMLFIND	= true

if $(not $(OCAMLFIND_EXISTS))
  eprintln (This project requires ocamlfind, but it was not found.)
  eprintln (You need to install ocamlfind and run "omake --configure".)
  exit 1

#
# This project uses menhir
#
global.MENHIR_ENABLED	= true

#
# Add the staging install directory to findlib's
# package search path.
#
global.OCAMLFIND	= OCAMLPATH=$(LIBDIR) $(OCAMLFIND)


private.mod-filename (mod) =
  # Check whether module names are capitalised.
  if $(equal $(mod), $(uncapitalize $(basename $(mod)))):
    eprintln (Module name '$(mod)' in target '$(Target)' does not follow OCaml conventions.)
    exit 1

  private.UC	= $(dirname $(mod))/$(capitalize $(basename $(mod)))
  private.LC	= $(dirname $(mod))/$(uncapitalize $(basename $(mod)))

  if $(target-exists $(UC).cmi):
    return $(UC)
  elseif $(target-exists $(LC).cmi):
    return $(LC)
  else:
    eprintln ($"*** warning: Module '$(mod)' for target '$(Target)' does not exist and no rule to build it (tried $(UC) and $(LC))")
    return $(LC)


private.dependencies (Requires) =
  # Find out which packages are built in this project
  private.DEPS[]	= $(filter-targets $(addprefix $(LIBDIR)/, $(rootname $(Requires))))
  return $(addsuffix /META, $(DEPS))


public.ocamlfind-flags (file) =
  if $(Flags.mem $(basename $(file))):
    return $(Flags.find $(basename $(file)))


public.ocaml-dependencies () =
  global.OCAMLPACKS[]	+= $(Requires)
  global.OCAMLFINDFLAGS	+= $`(ocamlfind-flags $<)
  private.DEPEND	= $(dependencies $(Requires))

  # Make all targets depend on the dependencies' META files.
  %.opt %.cmxa %.cma %.cmx %.cmo %.cmi %.o: $(DEPEND)
  .SCANNER: scan-ocaml-%: $(DEPEND)

  export


private.ocaml-target () =
  ocaml-dependencies ()

  # Find the files for the target's modules.
  protected.BASENAMES =
    foreach (mod, $(Modules)):
      mod-filename ($(mod))

  export


private.ocaml-meta (META, files) =
  private.emit-syntax-package () =
    echo							>> $@
    echo 'package "syntax" ('					>> $@
    echo '  description = "Syntax extension for $(Target)"'	>> $@
    echo '  version = "$(Version)"'				>> $@
    echo '  requires = "pa_$(Target)"'				>> $@
    echo '  archive(syntax, preprocessor) = "pa_$(Target).cma"'	>> $@
    echo ')'							>> $@

  Shell. +=
    emit-meta (argv) =
      # Check if this target is a syntax extension and there is a support
      # library for this target. If so, add a runtime dependency on it to
      # the META file.
      private.SUPPORT = $(removeprefix pa_, $(Target))
      if $(and $(not $(equal $(SUPPORT), $(Target))), $(target-exists $(LIBDIR)/$(SUPPORT))):
        Requires += $(SUPPORT)
        export

      echo '# digests' $(digest $+)		>  $@
      echo 'description="$(Description)"'	>> $@
      echo 'version="$(Version)"'		>> $@
      echo 'requires="$(Requires)"'		>> $@
      if $(BYTE_ENABLED):
        echo 'archive(byte)="$(Target).cma"'	>> $@
      if $(NATIVE_ENABLED):
        echo 'archive(native)="$(Target).cmxa"'	>> $@
      echo 'exists_if="$(basename $(files))"'	>> $@
      # If this is the support library for a syntax extension, add a
      # $(Target).syntax sub-package to the META file depending on the
      # syntax extension.
      if $(target-exists $(LIBDIR)/pa_$(Target)):
        emit-syntax-package ()

  # Rules
  $(META): $(files) $(if $(target-exists $(LIBDIR)/pa_$(Target)), $(LIBDIR)/pa_$(Target)/META, $(EMPTY))
	emit-meta


public.ocaml-library () =
  ocaml-target ()

  private.INSTDIR	= $(LIBDIR)/$(Target)
  $(INSTDIR):
	mkdir -p $@
  mkdir -p $(INSTDIR)

  if $(CSources):
    OCAML_LIB_FLAGS	= -cclib '-L$(INSTDIR) -l$(Target)_stubs' $(OCAML_LIB_FLAGS)
    export

  # META file
  private.META		= $(INSTDIR)/META

  # Library targets
  private.FILES		= $(OCamlLibraryInstall $(META), $(INSTDIR), $(Target), $(BASENAMES))

  ocaml-meta ($(META), $(FILES))

  if $(CSources):
    $(FILES): $(StaticCLibraryInstall $(META), $(INSTDIR), lib$(Target)_stubs, $(CSources))
    $(FILES): $(CHeaders)
    export

  .DEFAULT: $(META) $(FILES)
  export


public.ocaml-pack () =
  private.PACK		= $(capitalize $(Target))
  global.OCAMLFLAGS	+= $`(match $<, \.ml, -for-pack $(PACK))

  # Compute BASENAMES and dependencies
  ocaml-target ()

  private.FILES		= $(OCamlPackage $(Target), $(BASENAMES))

  global.Modules[]	= $(PACK)

  .DEFAULT: $(ocaml-library)
  export


public.ocaml-program () =
  ocaml-target ()

  .DEFAULT: $(OCamlProgramInstall $(Target).staging, $(BINDIR), $(Target), $(BASENAMES))
  export
