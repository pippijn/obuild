# Required OCaml libraries
OCaml-Requires	= $(EMPTY)

# OCaml module names, to be mapped to sources in ocaml-prepare.
Modules[]	= $(EMPTY)


private.ocamlfind (pkg) =
  .STATIC: :key: $(pkg)
    msg-checking (for $(pkg))
    result =
      if $(equal $(shell-code ocamlfind -query $(pkg) >& /dev/null), 0):
        value $(shell ocamlfind -query $(pkg))
      else
        path = $(ocaml-libdir)/$(rootname $l)
        if $(target-exists $(path)):
          value $(basename $(path)) is built in this project
        else
          value false
    msg-found ($(result))
  value $(result)


find-ocaml-requires () =
  foreach (l, $(OCaml-Requires)):
    # System-installed or built within this project tree.
    if $(not $(ocamlfind $l)):
      msg-warn ($"package `$l' required for `$(Name)' not found")


private.map-modules () =
  SOURCES[] = $(EMPTY)

  foreach (m, $(Modules)):
    private.UC = $(file $(dirname $m)/$(capitalize $(basename $m)))
    private.LC = $(file $(dirname $m)/$(uncapitalize $(basename $m)))

    if $(equal $m, $(LC)):
      msg-error ($"module name `$m' in target $(Name) does not follow OCaml conventions")

    export SOURCES

    if $(target-exists $(UC).cmi):
      SOURCES += $(UC)
    elseif $(target-exists $(LC).cmi):
      SOURCES += $(LC)
    else
      msg-warn ($"module `$m' for target $(Name) does not exist
             and no rule to build it (tried $(UC) and $(LC))")
      SOURCES += $(LC)

  value $(SOURCES)


ocaml-recurse () =
  if $(OCaml-Requires):
    DEPEND = $(addsuffix /META, $(ocaml-filter-targets $(OCaml-Requires)))

    # Make all targets depend on its OCaml requirements.
    %.native %.byte %.cmxs %.cmxa %.cma %.cmx %.cmo %.cmi %.a %.o: $(DEPEND)
    .SCANNER: scan-ocaml-%: $(DEPEND)
    export
  export


ocaml-prepare () =
  ocaml-recurse ()
  OCaml-Sources[] = $(map-modules)
  if $(OCaml-Sources):
    Language = ocaml
    export
  export
