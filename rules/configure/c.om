# Required C libraries
C-Requires	= $(EMPTY)


private.version-requirement (kind) =
  switch $(kind)
  case >=:
    value atleast-version
  case =:
    value exact-version
  case <=:
    value max-version
  default:
    msg-error ($"expected >=, = or <=: $(kind)")


private.check-versions (requirements) =
  if $(lt $(length $(requirements)), 2):
    msg-error ($"version requirements invalid: $(requirements)")

  kind = $(version-requirement $(nth 0, $(requirements)))
  ver = $(nth 1, $(requirements))
  if $(not $(pkg-exists --$(kind)=$(ver) $(pkg))):
    msg-warn (package $(pkg) is version $(pkg-config --modversion $(pkg)))
    msg-warn (but $(Name) needs $(kind) $(ver))
  if $(gt $(length $(requirements)), 2):
    check-versions ($(nth-tl 2, $(requirements)))


find-c-package (requirements) =
  pkg = $(nth 0, $(requirements))
  .STATIC: :key: $(pkg)
    msg-checking (for $(pkg))
    if $(pkg-exists $(pkg)):
      msg-found ($(pkg-config --modversion $(pkg)))
      # If the version doesn't match, warn about it but continue, anyway
      if $(ge $(length $l), 2):
        check-versions ($(nth-tl 1, $l))
      PKG_CFLAGS	= $(pkg-config --cflags $(pkg))
      PKG_LIBS		= $(pkg-config --libs $(pkg))
      export PKG_CFLAGS PKG_LIBS
    else
      msg-found ($"-l$(pkg)")
      if $(ge $(length $l), 2):
        msg-warn ($"package $(pkg) does not carry version information; ignoring requirements")
      PKG_CFLAGS	= $(EMPTY)
      PKG_LIBS		= -l$(pkg)
      export PKG_CFLAGS PKG_LIBS

  CFLAGS	+= $(PKG_CFLAGS)
  CXXFLAGS	+= $(PKG_CFLAGS)
  LDFLAGS	+= $(PKG_LIBS)
  export CFLAGS CXXFLAGS LDFLAGS


find-c-requires () =
  export CFLAGS CXXFLAGS LDFLAGS

  foreach (l, $(C-Requires)):
    find-c-package ($l)


c-recurse () =
  %.o: $(Headers)
  export


c-prepare () =
  c-recurse ()
  export
