open rules/build/common

OCAMLINCLUDES[]		= $(EMPTY)
COMPILEFLAGS		= $(EMPTY)
LINKFLAGS		= $(EMPTY)

OCAML_BYTE		= true
OCAML_NATIVE		= true
OCAML_PLUGIN		= true


.STATIC:
  OCAMLFIND	= $(check-prog ocamlfind)

# Private variables for this omake module.
ocaml-libdir	= $(libdir)/ocaml

# Let ocamlfind know about our staged install.
OCAMLFIND	= OCAMLPATH=$(ocaml-libdir) $(OCAMLFIND)


###########################################################
# :: Common preparation for OCaml targets
###########################################################

PACKS () =
  if $(nonempty $(OCaml-Requires)):
    value -package $(concat \,, $(OCaml-Requires))

INCLUDES	= $`(mapprefix -I, $(OCAMLINCLUDES) $(recurse-subdirs))
OCAMLFLAGS	= $`(PACKS) $`(USERFLAGS) $(INCLUDES)


OCAMLC		= $(OCAMLFIND) ocamlc   $(OCAMLFLAGS)
OCAMLOPT	= $(OCAMLFIND) ocamlopt $(OCAMLFLAGS)
OCAMLDEP	= $(OCAMLFIND) ocamldep $(OCAMLFLAGS)


.ORDER: .OCAMLLINK

.OCAMLLINK: %.cmi: %.cmo
.OCAMLLINK: %.cmx: %.cmo

link-sort (nodes) =
  value $(file-sort .OCAMLLINK, $(nodes))


ocaml-target-exists (library) =
  value $(mem $(rootname $(library)), $(OCAML_LIBS_INSTALLED))

ocaml-filter-targets (targets) =
  private.TARGETS = $(intersection $(rootname $(targets)), $(OCAML_LIBS_INSTALLED))
  value $(addprefix $(ocaml-libdir)/, $(TARGETS))


###########################################################
# :: OCaml dependency scanners
###########################################################

private.print-dep (srcbase, srcsuff, targetbase) =
  base = $(file $(targetbase))
  if $(target-exists $(base).cmi):
    switch $(srcsuff)
    case .mli:
      println ($"$(srcbase).cmi: $(base).cmi")
    case .ml:
      println ($"$(srcbase).cmo: $(base).cmo")
      println ($"$(srcbase).cmx: $(base).cmx")
    default:
      msg-error ($"unknown suffix for ocaml source file: $(srcsuff)")
    value true
  else
    value false


private.try-print-dep (prefix, srcbase, srcsuff, targetbase) =
  if $(print-dep $(srcbase), $(srcsuff),	\
       $(prefix)/$m):
    value true
  elseif $(print-dep $(srcbase), $(srcsuff),	\
           $(prefix)/$(dirname $m)/$(uncapitalize $(basename $m))):
    value true
  else
    value false


private.process-dep () =
  awk (b, $(stdin))
  case $'^\(.*\):[[:space:]]*\(.*\)$':
    srcbase	= $(removesuffix $1)
    srcsuff	= $(suffix $1)

    foreach (d, $(split $' ', $2)):
      foreach (m, $(Modules)):
        if $(equal $d, $(basename $m)):
          if $(try-print-dep ., $(srcbase), $(srcsuff), $m):
            value
          elseif $(try-print-dep $(curdir), $(srcbase), $(srcsuff), $m):
            value
          else
            if $(curdir):
              msg-error (could not find source file for module '$m')
            else
              msg-error (could not find source file for module '$m' and curdir is not set)

  default:
    msg-error (invalid ocamldep output: $0)


Shell. +=
  ocaml-dep (argv) =
    process-dep ()


.SCANNER: scan-ocaml-%.mli: %.mli
  $(OCAMLDEP) $(OCAMLFLAGS) -modules $< | ocaml-dep
  
.SCANNER: scan-ocaml-%.ml: %.ml
  #eprintln ($"EHEHEH $(dependencies $@)")
  $(OCAMLDEP) $(OCAMLFLAGS) -modules $< | ocaml-dep


###########################################################
# :: Rules for compiling OCaml files
###########################################################

%.cmx %$(OBJEXT): %.ml
  section rule:
    if $(or $(target-exists %.mli), $(OCAML_BYTE)):
      # If the .mli exists, we get the .cmi from that,
      # if byte-code is enabled, we produce the .cmi in its rule.
      %.cmx %$(OBJEXT): %.ml %.cmi :scanner: scan-ocaml-%.ml
        $(OCAMLOPT) $(COMPILEFLAGS) -c $<
    else
      # Otherwise, the .cmi is produced in this rule.
      %.cmx %.cmi %$(OBJEXT): %.ml :scanner: scan-ocaml-%.ml
        $(OCAMLOPT) $(COMPILEFLAGS) -c $<


%.cmo: %.ml
  section rule:
    if $(target-exists %.mli):
      %.cmo: %.ml %.cmi :scanner: scan-ocaml-%.ml
        $(OCAMLC) $(COMPILEFLAGS) -c $<
    else
      %.cmo %.cmi: %.ml :scanner: scan-ocaml-%.ml
        $(OCAMLC) $(COMPILEFLAGS) -c $<


%.cmi: %.ml
  section rule:
    if $(OCAML_BYTE):
      %.cmo %.cmi: %.ml :scanner: scan-ocaml-%.ml
        $(OCAMLC) $(COMPILEFLAGS) -c $<
    else
      %.cmx %.cmi %$(OBJEXT): %.ml :scanner: scan-ocaml-%.ml
        $(OCAMLOPT) $(COMPILEFLAGS) -c $<


%.cmi: %.mli :scanner: scan-ocaml-%.mli
  $(OCAMLC) $(COMPILEFLAGS) -c $<


###########################################################
# :: Common utilities
###########################################################

# Basenames for OCaml module sources.
ocaml-basenames () =
  value $(set $(OCaml-Sources))


ocaml-link (objects) =
  value $(link-sort $(objects)) $(LINKFLAGS)
