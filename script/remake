#!/usr/bin/env perl

use common::sense;

use Cwd 'abs_path';
use Dir::Self;
use File::Find;
use Text::CSV;
use Time::HiRes 'gettimeofday';

use constant {
   SRCDIR   => "src",
   TAGFILE  => (abs_path "src/.remake"),
   DEBUG    => 0,
};

# Flush as soon as possible.
$|++;

my $DIRECT = $ARGV[0] ne "-on-demand";

my @pids = do {
   if (open my $fh, '<', TAGFILE) {
      my $data = <$fh>;
      $data =~ /^(\d+) (\d+)$/
   } else {
      ()
   }
};

# Check whether the old remake process still exists
# and delete the old tag file if not.
if (@pids and not kill 0, $pids[0]) {
   my ($remake, $omake) = @pids;

   print "*** remake: old instance $remake no longer alive; removing tag file\n";
   unlink TAGFILE
      or die "could not remove old tag file";

   # Kill old omake.
   if (kill 0, $omake) {
      print "*** remake: waiting for old omake instance $omake to die ";
      kill 2, $omake;
      while (kill 0, $omake) {
         print '.';
         sleep 1;
      }
      print "\n";
   }

   # We are now the new remake, so we don't need
   # to exit.
   undef @pids;
}

if (not $DIRECT) {
   shift @ARGV;
}

# Touch update-file.
sub touch {
   open my $fh, '>', TAGFILE
      or die "could not open tag file for writing";
   print $fh join " ", $$, @_;
}

if (@pids) {
   print "*** remake: updating running instance $pids[0]\n";
   touch;
   exit
}

my $omake = fork;
if ($omake) {
   $SIG{INT} = sub { exit };
   END { if ($omake) { kill 2, $omake; waitpid $omake, 0; unlink TAGFILE } }
} else {
   exec __DIR__ . "/obuild", "-P", @ARGV
}

touch $omake;

my $csv = new Text::CSV { binary => 1 };
open my $pipe, '-|', qw|inotifywait -q -m --csv -e close_write -r|, SRCDIR;

my %links;
sub collect_links {
   my $start = gettimeofday;

   %links = ();
   find {
      wanted => sub {
         if (-l) {
            my $abs = abs_path $_ or die "$_: $!";
            push @{ $links{$abs} }, $_;
         }
      },
      no_chdir => 1,
   }, '.';

   my $end = gettimeofday;

   my $sum = 0;
   $sum += @$_ for values %links;
   printf "*** remake: watching %d symbolic links to %d files (%.02f sec)\n"
      , $sum
      , scalar keys %links
      , ($end - $start)
      ;
}

sub update_link {
   my ($target) = @_;
   my $source = readlink $target;

   if (DEBUG) {
      printf "*** remake: updating link %s -> %s\n"
         , $target
         , $source
         ;
   }
   # This is an atomic link-touch, so inotify in omake is triggered.
   kill 19, $omake; # STOP omake
   unlink $target; # remove old link
   symlink $source, $target or die $!; # re-create link
   kill 18, $omake; # CONT omake
}

sub update_tag {
   touch $omake;

   my $row = $csv->getline ($pipe);
   my $file = abs_path "$row->[0]$row->[2]";

   die "*** remake: file system race detected"
      unless $file eq TAGFILE;
}

# Initial reading of symlinks.
collect_links;

# Hash-set of changed nodes.
my %changed;
while (my $row = $csv->getline ($pipe)) {
   my @events = split ',', $row->[1];
   my $file = abs_path "$row->[0]$row->[2]";

   if ($file eq TAGFILE) {
      update_link $_ for keys %changed;
      %changed = ();

      update_tag;

      # This is actually too early, so maybe the user needs to
      # call it again after omake has finished.
      collect_links;
   } else {
      for my $target (@{ $links{$file} }) {
         if (not $DIRECT) {
            $changed{$target} = undef;
         } else {
            update_link $target
         }
      }
   }
}
