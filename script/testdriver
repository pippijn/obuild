#!/usr/bin/env perl

use feature 'switch';
use common::sense;
use Term::ANSIColor ':constants';
use Time::HiRes 'gettimeofday';

use constant {
   TIMEOUT => 30,
};

my $expfn = shift @ARGV; -f $expfn or die "missing exp file: '$expfn'";
my $outfn = shift @ARGV or die "missing .out";

print "[", BOLD CYAN, "EXEC", RESET, "] $outfn\n";

my $start = gettimeofday;
my @output = do {
   local $SIG{ALRM} = sub { die "alarm\n" };

   my $pid = open my $fh, '-|';
   die "cannot fork: $!" unless defined $pid;

   if ($pid == 0) {
      alarm TIMEOUT;
      open STDERR, '>&', \*STDOUT
         or die "cannot dup STDOUT: $!";
      exec @ARGV;
   }

   my @output;
   eval {
      alarm TIMEOUT + 1;
      while (<$fh>) {
         chomp;
         push @output, $_;
      }
   };
   kill 9, $pid;

   waitpid $pid, 0;
   if ($? == -1) {
      push @output, "failed to execute: $!";
   }
   given ($? & 127) {
      when (0) { }
      when (9) {
         push @output, "<killed>";
      }
      when (11) {
         push @output, "<segmentation fault>";
      }
      when (14) {
         push @output, "<timeout>";
      }
      default {
         push @output, sprintf "<child died with signal %d>", $? & 127;
      }
   }
   @output
};
my $end = gettimeofday;

my $output = join "\n", @output, ""; # newline at eof
# Print output to .out file
{
   open my $fh, '>', $outfn or die "$outfn: $!";
   print $fh $output;
}

# Read .exp contents
my $expect = do {
   local $/;
   open my $fh, '<', $expfn
      or die "$expfn: $!";
   <$fh>
};

my @result = do {
   if ($output[$#output] eq '<timeout>') {
      BOLD YELLOW, "TIME", RESET
   } elsif ($output eq $expect) {
      BOLD GREEN , "PASS", RESET
   } else {
      BOLD RED   , "FAIL", RESET
   }
};

printf "\e[A[%s] %-20s %.03f sec\n"
   , (join "", @result)
   , $outfn
   , ($end - $start)
   ;
